#include "huffman.h"
#include "filewriter.h"
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>


void write_header_file(FILE *fp, const char *exename, const char *infile, const char *outfile_name, const char *output_objname, size_t uncompressed_data_size, uint32_t comp_word_ct, uint32_t node_ct, uint32_t gba_table_len, DataSize_e huffcode_bitdepth, _Bool src_is_asm) {
  char header_guard_macroname[(strlen(outfile_name) - 2) + 1];
  int i, header_guard_namelen = sizeof(header_guard_macroname)-1;
  for (char c = outfile_name[i=0]; '.'!=c; c = outfile_name[++i]) {
    header_guard_macroname[i] = isalpha(c) ? toupper(c) : '_';
  }
  header_guard_macroname[header_guard_namelen] = '\0';
  

  fprintf(fp,
      "// Autogenerated GBA Huffman Compression Header File using %s by Burton O Sumner 2024 (C)\n"
      "// ---------------------------------------------------------------------------------------\n"
      "// Input File Name:\t\t%s\n"
      "// Input File Original Size:\t%lu (Padded to 4-byte alignment)\n"
      "// ---------------------------------------------------------------------------------------\n"
      "// Compressed Data Name:\t%s\n"
      "// Compressed Data Size:\t%u (Padded to 4-byte alignment)\n"
      "// ---------------------------------------------------------------------------------------\n"
      "// Huffman Tree Node Count:\t%u\n"
      "// Huffman Tree Size:\t\t%u\n"
      "// Huffcode Bitdepth:\t\t%d\n"
      "// ---------------------------------------------------------------------------------------\n\n\n",
      exename, infile, uncompressed_data_size, output_objname, comp_word_ct*4, node_ct, gba_table_len-1,
      huffcode_bitdepth);
  
  
  fprintf(fp, "#ifndef _%s_H_\n#define _%s_H_\n\n", header_guard_macroname, header_guard_macroname);

  fputs("#ifdef __cplusplus\nextern \"C\" {\n#else\n#include <stdbool.h>\n#endif  /* C++ name mangler guard opener */\n\n", fp);


  fputs("// Use this macro to declare the empty data buffer you want the decompressed data stored in.\n", fp);
  fprintf(fp, "#define %s_Decompressed_Data_Size %lu\n\n", output_objname, uncompressed_data_size);
  fputs("/* Use the below macro to know how large the tree table is. To get offset of raw compressed data,\n"
      " * add size of header ( PLUS 1 for the tree node count byte situated, contiguously, between the header and the root node\n"
      " * entry of the huffman tree table): raw compressed data addr is %s_Huffman_Compression_Data + sizeof(GBA_Huffman_Compression_Header_t) + 1 + %s_Huffman_Tree_Size\n"
      " * */\n", fp);
  fprintf(fp, "#define %s_Huffman_Tree_Size %u\n\n", output_objname, gba_table_len-1);

  fputs("/**\n"
      " * This is the pointer you need to pass to SVC for GBA's BIOS-provided Huffman Decompression routine\n"
      " * via R0 (aka function param 0)\n"
      " * */\n", fp);
  fprintf(fp, "extern const unsigned int %s_Huffman_Compression_Data[%lu];\n\n",
      output_objname, (sizeof(HuffHeader_GBA_t) + gba_table_len)/4 + comp_word_ct);
  
  fputs("/* Define header bitfield structs only if they weren't already\n"
      " * defined in another huffcode data file, hence the nested header guard here\n"
      " * */\n", fp);
  fputs("#ifndef _GBA_HUFFDECOMP_HDR_FIELD_TYPEDEFS_\n"
      "#define _GBA_HUFFDECOMP_HDR_FIELD_TYPEDEFS_\n\n", fp);

  fputs("/* Below are some helpful typedefs and macros to get an idea how the above\n"
      " * compression data is formatted:\n"
      " * */\n\n", fp);

  fputs("typedef struct {\n\t"
      "unsigned int huffcode_bit_depth : 4;  /// How many bits of is encoded in data each huffman code\n\t"
      "const unsigned int RESERVED_ID_FIELD : 4;  /// Reserved field, used by BIOS routine to identify compression type\n\t"
      "unsigned int decompressed_data_size : 24;  /// Size of data after being decompressed\n"
      "} __attribute__ ((packed)) GBA_Huffman_Compression_Header_t;\n\n", fp);

  fputs("typedef struct {\n\t"
      "unsigned int descendants_ofs : 6;  /// Offset from current node to its child nodes\n\t"
      "bool r_is_leaf : 1;  /// True:= This node's right child node is a leaf, not a subroot\n\t"
      "bool l_is_leaf : 1;  /// True:= This node's left child node is a leaf, not a subroot\n"
      "} __attribute__ ((packed)) GBA_Huffman_Tree_Subroot_t;\n\n", fp);
  
  fputs("typedef union {\n\t"
      "GBA_Huffman_Tree_Subroot_t subroot;  /// Access this union field if node is a subroot\n\t"
      "unsigned char leaf;  // Access this union field if node is a leaf;\n\t"
      "                     // leaves give the value encoded by the huffman code their position in the tree yields\n"
      "} __attribute__ ((packed)) GBA_Huffman_Tree_Node_t;\n\n", fp);

  fputs("#endif  /* _GBA_HUFFDECOMP_HDR_FIELD_TYPEDEFS_ */\n\n", fp);
  
  if (!src_is_asm) {
    fprintf(fp, "#define %s_Huffman_Compression_Header (*(GBA_Huffman_Compression_Header_t*)%s_Huffman_Compression_Data)\n", output_objname, output_objname);
    fprintf(fp, "#define %s_Huffman_Tree_Nodes_Table (((GBA_Huffman_Tree_Node_t*)%s_Huffman_Compression_Data) + sizeof(GBA_Huffman_Compression_Header_t) +1)\n", output_objname, output_objname);
    fprintf(fp, "#define %s_Huffman_Raw_Compressed_Data ((void*) (%s_Huffman_Compression_Data + (sizeof(GBA_Huffman_Compression_Header_t) + 1 + %s_Huffman_Tree_Size)/4))\n", output_objname, output_objname, output_objname);
  } else {
    fprintf(fp, "extern const GBA_Huffman_Compression_Header_t %s_Huffman_Compression_Header;\n", output_objname);
    fprintf(fp, "extern const GBA_Huffman_Tree_Node_t %s_Huffman_Tree_Nodes_Table[%s_Huffman_Tree_Size];\n", output_objname, output_objname);
    fprintf(fp, "extern const unsigned int %s_Huffman_Raw_Compressed_Data[%u];\n", output_objname, comp_word_ct);
  }


  fputs("\n\n", fp);

  fputs("#ifdef __cplusplus\n}\n#endif  /* C++ name mangler guard closer */\n\n", fp);
  fprintf(fp, "#endif  /* _%s_H_ */\n", header_guard_macroname);
}


void write_c_src_file(FILE *fp, const char *exename, const char *infile, const char *output_objname, size_t uncompressed_data_size, uint32_t *compdata, uint32_t comp_word_ct, HuffHeader_GBA_t gba_header, HuffTree_t *hufftree, HuffNode_GBA_t *gba_hufftree, uint32_t gba_table_len, DataSize_e huffcode_bitdepth) {
  fprintf(fp, 
      "// Autogenerated GBA Huffman Compression Source File using %s by Burton O Sumner 2024 (C)\n"
      "// ---------------------------------------------------------------------------------------\n"
      "// Input File Name:\t\t%s\n"
      "// Input File Original Size:\t%lu (Padded to 4-byte alignment)\n"
      "// ---------------------------------------------------------------------------------------\n"
      "// Compressed Data Name:\t%s\n"
      "// Compressed Data Size:\t%u (Padded to 4-byte alignment)\n"
      "// ---------------------------------------------------------------------------------------\n"
      "// Huffman Tree Node Count:\t%u\n"
      "// Huffman Tree Size:\t\t%u\n"
      "// Huffcode Bitdepth:\t\t%d\n"
      "// ---------------------------------------------------------------------------------------\n\n\n",
      exename, infile, uncompressed_data_size, output_objname, comp_word_ct*4, hufftree->node_ct, gba_table_len-1,
      huffcode_bitdepth);

  fprintf(fp, "const unsigned int %s_Huffman_Compression_Data[%lu] = {\n\t",
      output_objname, (sizeof(HuffHeader_GBA_t) + gba_table_len)/4 + comp_word_ct);
  int column_number = 1;
  {
    const uint32_t *cursor, *last;
    fprintf(fp, "0x%08X,", *((uint32_t*) &gba_header));
    assert((gba_table_len&3) == 0);
    cursor = (uint32_t*)gba_hufftree;
    for (int i = 0, table_word_ct = gba_table_len>>2; i++ < table_word_ct; ++cursor)
      if (column_number++&7) {
        fprintf(fp, " 0x%08X,", *cursor);
      } else {
        fprintf(fp, "\n\t0x%08X,", *cursor);
        column_number = 1;
      }


    for (cursor = compdata, last = compdata + comp_word_ct - 1; cursor != last; ++cursor)
      if (column_number++&7) {
        fprintf(fp, " 0x%08X,", *cursor);
      } else {
        fprintf(fp, "\n\t0x%08X,", *cursor);
        column_number = 1;
      }
    
    if (column_number&7) {
      fprintf(fp, " 0x%08X\n};\n\n", *last);
    } else {
      fprintf(fp, "\n\t0x%08X\n};\n\n", *last);
    }
  }
}


void write_asm_src_file(FILE *fp, const char *exename, const char *infile, const char *output_objname, size_t uncompressed_data_size, uint32_t *compdata, uint32_t comp_word_ct, HuffHeader_GBA_t gba_header, HuffTree_t *hufftree, HuffNode_GBA_t *gba_hufftree, uint32_t gba_table_len, DataSize_e huffcode_bitdepth) {
  fprintf(fp, 
      "@  Autogenerated GBA Huffman Compression ASM (GNU Assembler Syntax) File using %s by Burton O Sumner 2024 (C)\n"
      "@  ---------------------------------------------------------------------------------------\n"
      "@  Input File Name:\t\t%s\n"
      "@  Input File Original Size:\t%lu (Padded to 4-byte alignment)\n"
      "@  ---------------------------------------------------------------------------------------\n"
      "@  Compressed Data Name:\t%s\n"
      "@  Compressed Data Size:\t%u (Padded to 4-byte alignment)\n"
      "@  ---------------------------------------------------------------------------------------\n"
      "@  Huffman Tree Node Count:\t%u\n"
      "@  Huffman Tree Size:\t\t%u\n"
      "@  Huffcode Bitdepth:\t\t%d\n"
      "@  ---------------------------------------------------------------------------------------\n\n\n",
      exename, infile, uncompressed_data_size, output_objname, comp_word_ct*4, hufftree->node_ct, gba_table_len-1,
      huffcode_bitdepth);

  fputc('\t', fp);
  fprintf(fp, ".section .rodata\n\t"
      ".align 4\n\t"
      ".global %s_Huffman_Compression_Data\n\t"
      ".type %s_Huffman_Compression_Data %%object\n\t"
      ".global %s_Huffman_Compression_Header\n\t"
      ".type %s_Huffman_Compression_Header %%object\n"
      "%s_Huffman_Compression_Data:\n"
      "%s_Huffman_Compression_Header:\n\t"
      ".word 0x%08X\n\t"
      ".size %s_Huffman_Compression_Header, .-%s_Huffman_Compression_Header\n\t",
      output_objname, output_objname, output_objname, output_objname, output_objname, 
      output_objname, *((uint32_t*) &gba_header), output_objname, output_objname);

  fprintf(fp, ".byte 0x%02X\n\t"
    ".global %s_Huffman_Tree_Nodes_Table\n\t"
      ".type %s_Huffman_Tree_Nodes_Table %%object\n"
      "%s_Huffman_Tree_Nodes_Table:\n\t", gba_hufftree[0].leaf,
      output_objname, output_objname, output_objname);

  fprintf(fp, ".byte 0x%02X\n\t", gba_hufftree[1].leaf);
  
  assert(((gba_table_len-2)&3) == 2);
  {
    // So, first 2 bytes of hufftree node table were the size metafield 
    // and the root treenode data, respectively. So all that's left is the root's 
    // subnodes, which we can write, first halfwordwise for one halfword, 
    // to get us back on word alignment, and then word-wise for the remainder
    fprintf(fp, ".hword 0x%04X", *((uint16_t*) &gba_hufftree[2]));
    const uint32_t *remaining_tree_words = ((uint32_t*) &gba_hufftree[4]),
             remaining_tree_word_ct = (gba_table_len - 4)/4;
    assert((gba_table_len-4) == (remaining_tree_word_ct*4));
    
    for (uint32_t i = 0, col = 0; i < remaining_tree_word_ct; col&=7, ++i) {
      if (!col++) {
        fprintf(fp, "\n\t.word 0x%08X", *remaining_tree_words++);
      } else {
        fprintf(fp, ", 0x%08X", *remaining_tree_words++);
      }
    }
    fprintf(fp, "\n\t"
        ".size %s_Huffman_Tree_Nodes_Table, .-%s_Huffman_Tree_Nodes_Table\n\t"
        ".global %s_Huffman_Raw_Compressed_Data\n\t"
        ".type %s_Huffman_Raw_Compressed_Data %%object\n"
        "%s_Huffman_Raw_Compressed_Data:", output_objname, output_objname, 
        output_objname, output_objname, output_objname);
  }

  const uint32_t *cur = compdata;
  for (uint32_t i = 0, col = 0; i < comp_word_ct; col&=7, ++i) {
    if (!col++) {
      fprintf(fp, "\n\t.word 0x%08X", *cur++);
    } else {
      fprintf(fp, ", 0x%08X", *cur++);
    }
  }

  fprintf(fp, "\n\t"
      ".size %s_Huffman_Raw_Compressed_Data, .-%s_Huffman_Raw_Compressed_Data\n\t"
      ".size %s_Huffman_Compression_Data, .-%s_Huffman_Compression_Data\n\n",
      output_objname, output_objname, output_objname, output_objname);
}
